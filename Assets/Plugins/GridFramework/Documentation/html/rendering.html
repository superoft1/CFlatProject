<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<title>Grid Framework: Rendering and drawing a Grid</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js.txt"></script>
<script type="text/javascript" src="dynsections.js.txt"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js.txt"></script>
<script type="text/javascript" src="navtreedata.js.txt"></script>
<script type="text/javascript" src="navtree.js.txt"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js.txt"></script>
<script type="text/javascript" src="search/search.js.txt"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Grid Framework
   &#160;<span id="projectnumber">2.1.6</span>
   </div>
   <div id="projectbrief">Easy grid setup and scripting for Unity 3D</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js.txt"></script>
<script type="text/javascript" src="menu.js.txt"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('rendering.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Rendering and drawing a Grid </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Rendering grids works separately from the rest of Unity's rendering pipeline. Unity renders meshes, but what we want to render are lines instead. For this reason Grid Framework does its own thing and then hooks into the rendering process at the appropriate point.</p>
<p>For a grid to be visible in the editor or at runtime you need a special <code>Renderer</code> component attached to the <code>GameObject</code> carrying the grid, and a <code>GridCamera</code> component attached to your camera. There can be more than one renderer for a grid type and you can even write your own renderers.</p>
<p>The rendering process of Grid Framework can be diverted by your own implementation if you prefer, you are not limited to the defaults.</p>
<h2>Render VS Draw </h2>
<p>Grid Framework lets you both draw and render the grid. While they share the same points and give similar results they work in different ways: drawing uses gizmos, rendering is done directly at a low level. Drawings won’t be visible in the game during runtime but they are visible in the editor, while the rendered grid is only visible in game view at runtime. Both serve the same purpose and together they complete each other. Use drawing when you want you to see the grid and use rendering when you want the player to see the grid.</p>
<h2>Setup </h2>
<p>Make sure the <code>GameObject</code> carrying your grid has an instance of a renderer component suitable for that grid attached. Most grids have only one type of renderer, but hex grids have multiple, plus you can write your own. You can also have several instances of a renderer per grid, they will all be drawn or rendered.</p>
<p>Attach the <code>GridCamera</code> component to all your cameras which are supposed to render the grid. Usually this would be your default camera. In the inspector you can make the camera render the grid even if it’s not the current main camera; this could be useful for example if you want the grid to appear on a mini-map.</p>
<p>Every renderer has its own properties to set, please consult the user manual and the scripting reference for details. All renderers have a priority, three colour fields, a material field and a line width. The <code>Priority</code> is used for sorting renderers to provide information on which renderers are drawn on top of which ones.</p>
<h2>Material and shader </h2>
<p>Every rendering process requires a material. If you don't specify your own material a default material will be generated from a shader. The shader is found in <code>Plugins/Grid Framework/Resources/Default.shader</code>. Being in a <code>Resources</code> directory the shader will be included by default in your build, so it should work out of the box.</p>
<h2>Rendering Performance </h2>
<p>Rendering, as well as drawing, is a two-step process: first we need to count the number of the two end points for each line, then compute them and then we need to actually render all those lines. Grid Framework will cache the computed points, meaning as long as you don't change your grid the points won't be re-computed again. That way we don't need to waste resources calculating the same values over and over again. However, the last step cannot be cached, we need to pass every single point to Unity's GL class every frame.</p>
<p>To improve performance you could adjust the rendering range of your renderer dynamically during gameplay to only render the area the player will be able to see. Of course frequently changing the range forces a re-computation of the points and defeats the purpose of caching. Still, the gain in performance can be worth it if you make sure to adjust the range only at certain thresholds. Keep in mind that if something is set not to render it won't just be invisible, it will not be rendered at all and prevent the loops from running. Turning off an axis or having a flat grid can make a noticeable difference (a 100 x 100 x 0 grid will perform much better than a 100 x 100 x 1 grid).</p>
<p>The <em>Endless Grid</em> example shows how you can create the illusion of a huge grid without actually having to render the whole thing. We only render the part that will be visible plus some extra buffer. Only when the camera has been moved ten world units from the last fixed position we readjust the rendering range, thus forcing a re-computation of the draw points. This is a compromise between performance and flexibility, we can still display a large grid without the huge overhead of actually having a large grid.</p>
<h2>The rendering process in detail </h2>
<p>I mentioned above that you are not limited to the default implementation of the rendering process. In order to be able to hook into the pipeline and divert it to your wishes you have to know how everything fits together.</p>
<p>The starting point are the renderers. Every instance of a renderer is independent of any other, but they all require a grid of their respective type. When a renderer is activated by Unity it calls a method to have it registered by the static <code>RendererManager</code> class. This class maintains a list of all renderers, sorted by their priority. When a renderer becomes disabled it unregisters itself. Renderers update their points on their own when they or their grid change.</p>
<p>The <code>RendererManager</code> class does not do anything by itself, it only maintains the list of active renderers and keeps it sorted. Another script can then read this list and do something with the properties and methods exposed by the renderers.</p>
<p>This is what the <code>GridCamera</code> script does. It uses a the <code>OnPostRender</code> method of its <code>Camera</code> to render the lines using Unity's low-level <code>GL</code> class. The exact implementation is irrelevant here, what matters is that <code>GridCamera</code> is where the actual lines are put on screen.</p>
<p>If you want your own rendering implementation you should have your script take the role of <code>GridCamera</code> instead. Here is an excerpt of how <code>GridCamera</code> reads the list of renderers:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> OnPostRender() {</div><div class="line">    <span class="keywordflow">foreach</span> (var gridRenderer <span class="keywordflow">in</span> RendererManager.Renderers) {</div><div class="line">        <span class="keywordflow">if</span> (gridRenderer.enabled) {</div><div class="line">            <span class="comment">// This is a method of GridCamera</span></div><div class="line">            RenderGrid(gridRenderer);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>The implementation of the private method <code>RenderGrid</code> is the abstraction that abstracts the act of putting lines on the screen.</p>
<h2>Rendering with Vectrosity </h2>
<p><a href="http://starscenesoftware.com/vectrosity.html">Vectrosity</a> is a 3rd party vector line drawing solution developed by Eric5h5 and not related to Grid Framework. If you own a license you can easily extract points from a grid in a format fit for use with Vectrosity via official extension methods for renderers. The included examples show how to combine both packages. For more information on how to use them together please refer to Grid Framework’s scripting reference and Vectrosity’s own documentation.</p>
<div class="image">
<img src="vectrosity.png.txt" alt="vectrosity.png"/>
<div class="caption">
an example of what is possible with Grid Framework and Vectrosity</div></div>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.3.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sun Sep 10 2017 00:05:37 for Grid Framework by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png.txt" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
